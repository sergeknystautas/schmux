# Lore System Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use 10x-engineer:executing-plans to implement this plan task-by-task.

**Goal:** Build a continual knowledge feedback loop where agents capture operational patterns and codebase knowledge ("lore") into a scratchpad, a curator LLM deduplicates and routes it into instruction files (CLAUDE.md, AGENTS.md, etc.), and a dashboard lets users review and apply proposals.

**Architecture:** Three-stage pipeline — (1) agents append raw JSONL entries to `.claude/lore.jsonl` which is overlay-compounded across workspaces, (2) a headless curator LLM reads raw entries + instruction files and produces multi-file merge proposals, (3) the dashboard surfaces proposals for human review, and applying spawns a temp worktree to commit and push a lore branch.

**Tech Stack:** Go (backend), React/TypeScript (dashboard), JSONL (scratchpad format), existing overlay compounding system, existing oneshot LLM infrastructure.

**Design spec:** `docs/specs/lore.md`

---

### Task 1: LoreConfig in config schema

**Files:**

- Modify: `internal/config/config.go:76-87` (Config struct fields)
- Modify: `internal/config/config.go:242-252` (near CompoundConfig/OverlayConfig)
- Modify: `internal/config/config.go:538-559` (near compound getters)
- Test: `internal/config/config_test.go`

**Step 1: Write the failing test**

```go
// In internal/config/config_test.go — add to existing file

func TestGetLoreEnabled_Default(t *testing.T) {
	c := &Config{}
	if !c.GetLoreEnabled() {
		t.Error("expected lore enabled by default")
	}
}

func TestGetLoreEnabled_Explicit(t *testing.T) {
	enabled := false
	c := &Config{Lore: &LoreConfig{Enabled: &enabled}}
	if c.GetLoreEnabled() {
		t.Error("expected lore disabled when explicitly set to false")
	}
}

func TestGetLoreTarget_FallsBackToCompound(t *testing.T) {
	c := &Config{Compound: &CompoundConfig{Target: "claude-haiku"}}
	if got := c.GetLoreTarget(); got != "claude-haiku" {
		t.Errorf("expected fallback to compound target, got %q", got)
	}
}

func TestGetLoreTarget_OwnTarget(t *testing.T) {
	c := &Config{
		Compound: &CompoundConfig{Target: "claude-haiku"},
		Lore:     &LoreConfig{Target: "claude-sonnet"},
	}
	if got := c.GetLoreTarget(); got != "claude-sonnet" {
		t.Errorf("expected lore-specific target, got %q", got)
	}
}

func TestGetLoreInstructionFiles_Defaults(t *testing.T) {
	c := &Config{}
	files := c.GetLoreInstructionFiles()
	expected := []string{"CLAUDE.md", "AGENTS.md", ".cursorrules", ".github/copilot-instructions.md"}
	if len(files) != len(expected) {
		t.Fatalf("expected %d files, got %d", len(expected), len(files))
	}
	for i, f := range expected {
		if files[i] != f {
			t.Errorf("expected files[%d]=%q, got %q", i, f, files[i])
		}
	}
}

func TestGetLoreCurateDebounceMs_Default(t *testing.T) {
	c := &Config{}
	if got := c.GetLoreCurateDebounceMs(); got != 30000 {
		t.Errorf("expected 30000, got %d", got)
	}
}

func TestGetLoreAutoPR_Default(t *testing.T) {
	c := &Config{}
	if c.GetLoreAutoPR() {
		t.Error("expected auto_pr false by default")
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./internal/config/ -run "TestGetLore"
```

Expected: FAIL — `LoreConfig` type and getter methods don't exist yet.

**Step 3: Write minimal implementation**

Add `LoreConfig` struct near the other config structs (after `OverlayConfig` around line 252):

```go
// LoreConfig represents configuration for the lore (continual learning) system.
type LoreConfig struct {
	Enabled          *bool    `json:"enabled,omitempty"`            // explicitly enable/disable (default: true)
	Target           string   `json:"llm_target,omitempty"`         // LLM target for curator (falls back to compound target)
	AutoPR           *bool    `json:"auto_pr,omitempty"`            // auto-create PR after pushing lore branch (default: false)
	CurateOnDispose  *bool    `json:"curate_on_dispose,omitempty"`  // trigger curator on session dispose (default: true)
	CurateDebounceMs int      `json:"curate_debounce_ms,omitempty"` // debounce for auto-curation (default 30000)
	PruneAfterDays   int      `json:"prune_after_days,omitempty"`   // days before pruning applied/dismissed entries (default 30)
	InstructionFiles []string `json:"instruction_files,omitempty"`  // instruction file patterns to manage
}
```

Add `Lore` field to the `Config` struct (around line 77, next to `Compound` and `Overlay`):

```go
Lore *LoreConfig `json:"lore,omitempty"`
```

Add default instruction files and getter methods (after the compound getters, around line 560):

```go
// DefaultInstructionFiles are the instruction file patterns checked by the lore curator.
var DefaultInstructionFiles = []string{
	"CLAUDE.md",
	"AGENTS.md",
	".cursorrules",
	".github/copilot-instructions.md",
}

func (c *Config) GetLoreEnabled() bool {
	if c == nil || c.Lore == nil || c.Lore.Enabled == nil {
		return true
	}
	return *c.Lore.Enabled
}

func (c *Config) GetLoreTarget() string {
	if c != nil && c.Lore != nil && c.Lore.Target != "" {
		return c.Lore.Target
	}
	return c.GetCompoundTarget()
}

func (c *Config) GetLoreAutoPR() bool {
	if c == nil || c.Lore == nil || c.Lore.AutoPR == nil {
		return false
	}
	return *c.Lore.AutoPR
}

func (c *Config) GetLoreCurateOnDispose() bool {
	if c == nil || c.Lore == nil || c.Lore.CurateOnDispose == nil {
		return true
	}
	return *c.Lore.CurateOnDispose
}

func (c *Config) GetLoreCurateDebounceMs() int {
	if c == nil || c.Lore == nil || c.Lore.CurateDebounceMs <= 0 {
		return 30000
	}
	return c.Lore.CurateDebounceMs
}

func (c *Config) GetLorePruneAfterDays() int {
	if c == nil || c.Lore == nil || c.Lore.PruneAfterDays <= 0 {
		return 30
	}
	return c.Lore.PruneAfterDays
}

func (c *Config) GetLoreInstructionFiles() []string {
	if c != nil && c.Lore != nil && len(c.Lore.InstructionFiles) > 0 {
		return c.Lore.InstructionFiles
	}
	return DefaultInstructionFiles
}
```

**Step 4: Run test to verify it passes**

```bash
go test ./internal/config/ -run "TestGetLore"
```

Expected: PASS

**Step 5: Commit**

```bash
git add internal/config/config.go internal/config/config_test.go
git commit -m "Add LoreConfig to config schema with getters and defaults"
```

---

### Task 2: Scratchpad package — data types and parsing

**Files:**

- Create: `internal/lore/scratchpad.go`
- Create: `internal/lore/scratchpad_test.go`

**Step 1: Write the failing test**

```go
// internal/lore/scratchpad_test.go
package lore

import (
	"os"
	"path/filepath"
	"testing"
	"time"
)

func TestParseEntry(t *testing.T) {
	line := `{"ts":"2026-02-13T14:32:00Z","ws":"ws-abc","agent":"claude-code","type":"operational","text":"use go run ./cmd/build-dashboard"}`
	entry, err := ParseEntry(line)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if entry.Workspace != "ws-abc" {
		t.Errorf("expected ws-abc, got %s", entry.Workspace)
	}
	if entry.Agent != "claude-code" {
		t.Errorf("expected claude-code, got %s", entry.Agent)
	}
	if entry.Type != "operational" {
		t.Errorf("expected operational, got %s", entry.Type)
	}
	if entry.Text != "use go run ./cmd/build-dashboard" {
		t.Errorf("unexpected text: %s", entry.Text)
	}
}

func TestParseStateChange(t *testing.T) {
	line := `{"ts":"2026-02-13T15:00:00Z","state_change":"proposed","entry_ts":"2026-02-13T14:32:00Z","proposal_id":"prop-123"}`
	entry, err := ParseEntry(line)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if entry.StateChange != "proposed" {
		t.Errorf("expected proposed, got %s", entry.StateChange)
	}
	if entry.ProposalID != "prop-123" {
		t.Errorf("expected prop-123, got %s", entry.ProposalID)
	}
}

func TestReadEntries_FiltersRaw(t *testing.T) {
	dir := t.TempDir()
	path := filepath.Join(dir, "lore.jsonl")
	content := `{"ts":"2026-02-13T14:32:00Z","ws":"ws-abc","agent":"claude-code","type":"operational","text":"fact one"}
{"ts":"2026-02-13T14:33:00Z","ws":"ws-abc","agent":"claude-code","type":"codebase","text":"fact two"}
{"ts":"2026-02-13T15:00:00Z","state_change":"proposed","entry_ts":"2026-02-13T14:32:00Z","proposal_id":"prop-123"}
`
	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		t.Fatal(err)
	}

	entries, err := ReadEntries(path, FilterRaw())
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	// "fact one" has a state_change to proposed, so only "fact two" is raw
	if len(entries) != 1 {
		t.Fatalf("expected 1 raw entry, got %d", len(entries))
	}
	if entries[0].Text != "fact two" {
		t.Errorf("expected 'fact two', got %s", entries[0].Text)
	}
}

func TestAppendEntry(t *testing.T) {
	dir := t.TempDir()
	path := filepath.Join(dir, "lore.jsonl")

	entry := Entry{
		Timestamp: time.Date(2026, 2, 13, 14, 32, 0, 0, time.UTC),
		Workspace: "ws-abc",
		Agent:     "claude-code",
		Type:      "operational",
		Text:      "test fact",
	}
	if err := AppendEntry(path, entry); err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	data, err := os.ReadFile(path)
	if err != nil {
		t.Fatal(err)
	}
	entries, err := ReadEntries(path, nil)
	if err != nil {
		t.Fatal(err)
	}
	if len(entries) != 1 {
		t.Fatalf("expected 1 entry, got %d; content: %s", len(entries), string(data))
	}
	if entries[0].Text != "test fact" {
		t.Errorf("expected 'test fact', got %s", entries[0].Text)
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./internal/lore/ -run "Test"
```

Expected: FAIL — package doesn't exist.

**Step 3: Write minimal implementation**

```go
// internal/lore/scratchpad.go
package lore

import (
	"bufio"
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"time"
)

// Entry represents a single lore scratchpad entry or state-change record.
type Entry struct {
	Timestamp   time.Time `json:"ts"`
	Workspace   string    `json:"ws,omitempty"`
	Agent       string    `json:"agent,omitempty"`
	Type        string    `json:"type,omitempty"`        // "operational" or "codebase"
	Text        string    `json:"text,omitempty"`
	StateChange string    `json:"state_change,omitempty"` // "proposed", "applied", "dismissed"
	EntryTS     string    `json:"entry_ts,omitempty"`     // references the ts of the entry being changed
	ProposalID  string    `json:"proposal_id,omitempty"`
}

// EntryFilter controls which entries are returned by ReadEntries.
type EntryFilter func(entries []Entry) []Entry

// FilterRaw returns only entries that have no state-change records overriding them.
func FilterRaw() EntryFilter {
	return func(entries []Entry) []Entry {
		// Build set of entry timestamps that have state changes
		changed := make(map[string]bool)
		for _, e := range entries {
			if e.StateChange != "" && e.EntryTS != "" {
				changed[e.EntryTS] = true
			}
		}
		// Return only lore entries (not state changes) whose ts is not in changed set
		var result []Entry
		for _, e := range entries {
			if e.StateChange != "" {
				continue // skip state-change records
			}
			tsStr := e.Timestamp.Format(time.RFC3339)
			if changed[tsStr] {
				continue // this entry has been promoted to a different state
			}
			result = append(result, e)
		}
		return result
	}
}

// ParseEntry parses a single JSONL line into an Entry.
func ParseEntry(line string) (Entry, error) {
	var e Entry
	if err := json.Unmarshal([]byte(strings.TrimSpace(line)), &e); err != nil {
		return Entry{}, fmt.Errorf("failed to parse entry: %w", err)
	}
	return e, nil
}

// ReadEntries reads all entries from a JSONL file and optionally filters them.
func ReadEntries(path string, filter EntryFilter) ([]Entry, error) {
	f, err := os.Open(path)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil
		}
		return nil, err
	}
	defer f.Close()

	var entries []Entry
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}
		e, err := ParseEntry(line)
		if err != nil {
			fmt.Printf("[lore] skipping malformed entry: %v\n", err)
			continue
		}
		entries = append(entries, e)
	}
	if err := scanner.Err(); err != nil {
		return nil, err
	}
	if filter != nil {
		entries = filter(entries)
	}
	return entries, nil
}

// AppendEntry appends a single entry to a JSONL file. Creates the file if it doesn't exist.
func AppendEntry(path string, entry Entry) error {
	if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
		return err
	}
	f, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	data, err := json.Marshal(entry)
	if err != nil {
		return err
	}
	if _, err := f.Write(append(data, '\n')); err != nil {
		return err
	}
	return nil
}

// AppendStateChange records a state transition for an entry.
func AppendStateChange(path, stateChange, entryTS, proposalID string) error {
	return AppendEntry(path, Entry{
		Timestamp:   time.Now().UTC(),
		StateChange: stateChange,
		EntryTS:     entryTS,
		ProposalID:  proposalID,
	})
}
```

Note: You'll need to add `"path/filepath"` to the imports.

**Step 4: Run test to verify it passes**

```bash
go test ./internal/lore/ -run "Test"
```

Expected: PASS

**Step 5: Commit**

```bash
git add internal/lore/scratchpad.go internal/lore/scratchpad_test.go
git commit -m "Add lore scratchpad package with JSONL parse, append, and filtering"
```

---

### Task 3: Overlay integration — add lore.jsonl to default paths

**Files:**

- Modify: `internal/config/config.go:562-565` (DefaultOverlayPaths)
- Test: `internal/config/config_test.go`

**Step 1: Write the failing test**

```go
func TestDefaultOverlayPaths_IncludesLore(t *testing.T) {
	found := false
	for _, p := range DefaultOverlayPaths {
		if p == ".claude/lore.jsonl" {
			found = true
			break
		}
	}
	if !found {
		t.Error("DefaultOverlayPaths should include .claude/lore.jsonl")
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./internal/config/ -run "TestDefaultOverlayPaths_IncludesLore"
```

Expected: FAIL

**Step 3: Write minimal implementation**

In `internal/config/config.go`, change `DefaultOverlayPaths` (line 562):

```go
var DefaultOverlayPaths = []string{
	".claude/settings.json",
	".claude/settings.local.json",
	".claude/lore.jsonl",
}
```

**Step 4: Run test to verify it passes**

```bash
go test ./internal/config/ -run "TestDefaultOverlayPaths_IncludesLore"
```

Expected: PASS

**Step 5: Commit**

```bash
git add internal/config/config.go internal/config/config_test.go
git commit -m "Add .claude/lore.jsonl to default overlay paths"
```

---

### Task 4: JSONL line-union merge fast path

When the compounding loop encounters a `.jsonl` file where both sides have diverged, instead of calling the LLM, perform a line-level union (deduplicate by full line content). This is cheaper and correct for append-only JSONL.

**Files:**

- Modify: `internal/compound/merge.go:78-132` (executeLLMMerge function)
- Test: `internal/compound/merge_test.go`

**Step 1: Write the failing test**

```go
func TestExecuteMerge_JSONLLineUnion(t *testing.T) {
	dir := t.TempDir()
	wsPath := filepath.Join(dir, "ws", ".claude", "lore.jsonl")
	overlayPath := filepath.Join(dir, "overlay", ".claude", "lore.jsonl")

	// Workspace has lines A and C
	writeFile(t, wsPath, `{"ts":"1","text":"A"}
{"ts":"3","text":"C"}
`)
	// Overlay has lines A and B
	writeFile(t, overlayPath, `{"ts":"1","text":"A"}
{"ts":"2","text":"B"}
`)

	// Both diverged from manifest, so this is LLMMerge action.
	// But for .jsonl, it should use line-union instead of LLM.
	content, err := ExecuteMerge(context.Background(), MergeActionLLMMerge, wsPath, overlayPath, nil)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	result := string(content)
	if !strings.Contains(result, `"text":"A"`) {
		t.Error("merged content should contain A")
	}
	if !strings.Contains(result, `"text":"B"`) {
		t.Error("merged content should contain B")
	}
	if !strings.Contains(result, `"text":"C"`) {
		t.Error("merged content should contain C")
	}

	// Verify A appears only once
	if strings.Count(result, `"text":"A"`) != 1 {
		t.Error("A should appear exactly once (deduped)")
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./internal/compound/ -run "TestExecuteMerge_JSONLLineUnion"
```

Expected: FAIL — currently `.jsonl` files go through the LLM path, and with `nil` executor they fall through to last-write-wins (workspace content only, losing overlay-only lines).

**Step 3: Write minimal implementation**

In `internal/compound/merge.go`, add a JSONL check at the top of `executeLLMMerge`:

```go
func executeLLMMerge(ctx context.Context, wsPath, overlayPath string, executor LLMExecutor) ([]byte, error) {
	wsContent, err := os.ReadFile(wsPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read workspace file: %w", err)
	}

	overlayContent, err := os.ReadFile(overlayPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read overlay file: %w", err)
	}

	// JSONL files: line-level union (no LLM needed)
	if strings.HasSuffix(wsPath, ".jsonl") {
		return mergeJSONLLines(wsContent, overlayContent, overlayPath)
	}

	// ... rest of existing function unchanged ...
}
```

Add the `mergeJSONLLines` function:

```go
// mergeJSONLLines performs a line-level union of two JSONL files.
// Deduplicates by exact line content. Preserves order: overlay lines first, then new workspace lines.
func mergeJSONLLines(wsContent, overlayContent []byte, overlayPath string) ([]byte, error) {
	seen := make(map[string]bool)
	var merged []string

	// Add overlay lines first (preserves existing order)
	for _, line := range strings.Split(strings.TrimSpace(string(overlayContent)), "\n") {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		if !seen[line] {
			seen[line] = true
			merged = append(merged, line)
		}
	}

	// Add workspace-only lines
	for _, line := range strings.Split(strings.TrimSpace(string(wsContent)), "\n") {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		if !seen[line] {
			seen[line] = true
			merged = append(merged, line)
		}
	}

	result := []byte(strings.Join(merged, "\n") + "\n")
	if err := os.WriteFile(overlayPath, result, 0644); err != nil {
		return nil, fmt.Errorf("failed to write merged JSONL: %w", err)
	}
	fmt.Printf("[compound] JSONL line-union merge: %d unique lines\n", len(merged))
	return result, nil
}
```

**Step 4: Run test to verify it passes**

```bash
go test ./internal/compound/ -run "TestExecuteMerge_JSONLLineUnion"
```

Expected: PASS

**Step 5: Commit**

```bash
git add internal/compound/merge.go internal/compound/merge_test.go
git commit -m "Add JSONL line-union fast path for overlay compounding"
```

---

### Task 5: Proposal store

**Files:**

- Create: `internal/lore/proposals.go`
- Create: `internal/lore/proposals_test.go`

**Step 1: Write the failing test**

```go
// internal/lore/proposals_test.go
package lore

import (
	"path/filepath"
	"testing"
)

func TestProposalStore_SaveAndLoad(t *testing.T) {
	dir := t.TempDir()
	store := NewProposalStore(dir)

	proposal := &Proposal{
		ID:           "prop-20260213-143200",
		Repo:         "schmux",
		Status:       ProposalPending,
		SourceCount:  3,
		Sources:      []string{"ws-abc", "ws-def"},
		FileHashes:   map[string]string{"CLAUDE.md": "sha256:abc"},
		ProposedFiles: map[string]string{"CLAUDE.md": "# Updated content"},
		DiffSummary:  "Added 1 item",
		EntriesUsed:  []string{"entry-1"},
	}

	if err := store.Save(proposal); err != nil {
		t.Fatalf("save failed: %v", err)
	}

	loaded, err := store.Get("schmux", "prop-20260213-143200")
	if err != nil {
		t.Fatalf("get failed: %v", err)
	}
	if loaded.DiffSummary != "Added 1 item" {
		t.Errorf("expected 'Added 1 item', got %q", loaded.DiffSummary)
	}
	if loaded.Status != ProposalPending {
		t.Errorf("expected pending, got %s", loaded.Status)
	}
}

func TestProposalStore_List(t *testing.T) {
	dir := t.TempDir()
	store := NewProposalStore(dir)

	for _, id := range []string{"prop-001", "prop-002"} {
		store.Save(&Proposal{ID: id, Repo: "myrepo", Status: ProposalPending})
	}
	store.Save(&Proposal{ID: "prop-003", Repo: "otherrepo", Status: ProposalPending})

	proposals, err := store.List("myrepo")
	if err != nil {
		t.Fatalf("list failed: %v", err)
	}
	if len(proposals) != 2 {
		t.Fatalf("expected 2 proposals for myrepo, got %d", len(proposals))
	}
}

func TestProposalStore_UpdateStatus(t *testing.T) {
	dir := t.TempDir()
	store := NewProposalStore(dir)
	store.Save(&Proposal{ID: "prop-001", Repo: "myrepo", Status: ProposalPending})

	if err := store.UpdateStatus("myrepo", "prop-001", ProposalApplied); err != nil {
		t.Fatalf("update failed: %v", err)
	}
	loaded, _ := store.Get("myrepo", "prop-001")
	if loaded.Status != ProposalApplied {
		t.Errorf("expected applied, got %s", loaded.Status)
	}
}

func TestProposalStore_IsStale(t *testing.T) {
	dir := t.TempDir()
	// Write a fake CLAUDE.md
	repoDir := filepath.Join(dir, "repo")
	writeTestFile(t, filepath.Join(repoDir, "CLAUDE.md"), "# Original")

	proposal := &Proposal{
		FileHashes: map[string]string{"CLAUDE.md": "sha256:wrong"},
	}

	stale, err := proposal.IsStale(repoDir)
	if err != nil {
		t.Fatal(err)
	}
	if !stale {
		t.Error("expected proposal to be stale when hashes don't match")
	}
}

func writeTestFile(t *testing.T, path, content string) {
	t.Helper()
	if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		t.Fatal(err)
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./internal/lore/ -run "TestProposalStore"
```

Expected: FAIL

**Step 3: Write minimal implementation**

```go
// internal/lore/proposals.go
package lore

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"time"
)

type ProposalStatus string

const (
	ProposalPending   ProposalStatus = "pending"
	ProposalStale     ProposalStatus = "stale"
	ProposalApplied   ProposalStatus = "applied"
	ProposalDismissed ProposalStatus = "dismissed"
)

// Proposal represents a curator-generated merge proposal.
type Proposal struct {
	ID               string            `json:"id"`
	Repo             string            `json:"repo"`
	CreatedAt        time.Time         `json:"created_at"`
	Status           ProposalStatus    `json:"status"`
	SourceCount      int               `json:"source_count"`
	Sources          []string          `json:"sources"`
	FileHashes       map[string]string `json:"file_hashes"`
	ProposedFiles    map[string]string `json:"proposed_files"`
	DiffSummary      string            `json:"diff_summary"`
	EntriesUsed      []string          `json:"entries_used"`
	EntriesDiscarded map[string]string `json:"entries_discarded,omitempty"`
}

// IsStale checks whether any instruction file has changed since the proposal was created.
func (p *Proposal) IsStale(repoDir string) (bool, error) {
	for relPath, expectedHash := range p.FileHashes {
		fullPath := filepath.Join(repoDir, relPath)
		content, err := os.ReadFile(fullPath)
		if err != nil {
			if os.IsNotExist(err) {
				return true, nil // file deleted = stale
			}
			return false, err
		}
		hash := sha256.Sum256(content)
		actualHash := "sha256:" + hex.EncodeToString(hash[:])
		if actualHash != expectedHash {
			return true, nil
		}
	}
	return false, nil
}

// ProposalStore manages proposals on disk at ~/.schmux/lore-proposals/<repo>/<id>.json.
type ProposalStore struct {
	baseDir string
}

func NewProposalStore(baseDir string) *ProposalStore {
	return &ProposalStore{baseDir: baseDir}
}

func (s *ProposalStore) repoDir(repo string) string {
	return filepath.Join(s.baseDir, repo)
}

func (s *ProposalStore) proposalPath(repo, id string) string {
	return filepath.Join(s.repoDir(repo), id+".json")
}

func (s *ProposalStore) Save(p *Proposal) error {
	dir := s.repoDir(p.Repo)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}
	data, err := json.MarshalIndent(p, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(s.proposalPath(p.Repo, p.ID), data, 0644)
}

func (s *ProposalStore) Get(repo, id string) (*Proposal, error) {
	data, err := os.ReadFile(s.proposalPath(repo, id))
	if err != nil {
		return nil, err
	}
	var p Proposal
	if err := json.Unmarshal(data, &p); err != nil {
		return nil, err
	}
	return &p, nil
}

func (s *ProposalStore) List(repo string) ([]*Proposal, error) {
	dir := s.repoDir(repo)
	entries, err := os.ReadDir(dir)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil
		}
		return nil, err
	}

	var proposals []*Proposal
	for _, entry := range entries {
		if entry.IsDir() || filepath.Ext(entry.Name()) != ".json" {
			continue
		}
		id := entry.Name()[:len(entry.Name())-5] // strip .json
		p, err := s.Get(repo, id)
		if err != nil {
			fmt.Printf("[lore] skipping malformed proposal %s: %v\n", entry.Name(), err)
			continue
		}
		proposals = append(proposals, p)
	}

	// Sort newest first
	sort.Slice(proposals, func(i, j int) bool {
		return proposals[i].CreatedAt.After(proposals[j].CreatedAt)
	})
	return proposals, nil
}

func (s *ProposalStore) UpdateStatus(repo, id string, status ProposalStatus) error {
	p, err := s.Get(repo, id)
	if err != nil {
		return err
	}
	p.Status = status
	return s.Save(p)
}

// HashFileContent returns a "sha256:<hex>" hash of a file's content.
func HashFileContent(path string) (string, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	hash := sha256.Sum256(content)
	return "sha256:" + hex.EncodeToString(hash[:]), nil
}
```

**Step 4: Run test to verify it passes**

```bash
go test ./internal/lore/ -run "TestProposalStore"
```

Expected: PASS

**Step 5: Commit**

```bash
git add internal/lore/proposals.go internal/lore/proposals_test.go
git commit -m "Add lore proposal store with disk-based CRUD and staleness detection"
```

---

### Task 6: Curator — LLM-based proposal generation

**Files:**

- Create: `internal/lore/curator.go`
- Create: `internal/lore/curator_test.go`

**Step 1: Write the failing test**

```go
// internal/lore/curator_test.go
package lore

import (
	"context"
	"encoding/json"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"
)

func TestBuildCuratorPrompt(t *testing.T) {
	files := map[string]string{
		"CLAUDE.md": "# Project\n\n## Build\ngo build",
	}
	entries := []Entry{
		{Text: "use go run ./cmd/build-dashboard", Type: "operational"},
	}
	prompt := BuildCuratorPrompt(files, entries)
	if !strings.Contains(prompt, "CLAUDE.md") {
		t.Error("prompt should contain filename")
	}
	if !strings.Contains(prompt, "go build") {
		t.Error("prompt should contain file content")
	}
	if !strings.Contains(prompt, "use go run ./cmd/build-dashboard") {
		t.Error("prompt should contain entry text")
	}
}

func TestParseCuratorResponse(t *testing.T) {
	response := `{
		"proposed_files": {"CLAUDE.md": "# Updated"},
		"diff_summary": "Added 1 item",
		"entries_used": ["entry-1"],
		"entries_discarded": {"entry-2": "already covered"}
	}`
	result, err := ParseCuratorResponse(response)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result.ProposedFiles["CLAUDE.md"] != "# Updated" {
		t.Errorf("unexpected proposed content: %s", result.ProposedFiles["CLAUDE.md"])
	}
	if result.DiffSummary != "Added 1 item" {
		t.Errorf("unexpected summary: %s", result.DiffSummary)
	}
}

func TestCurate_NoRawEntries(t *testing.T) {
	dir := t.TempDir()
	repoDir := filepath.Join(dir, "repo")
	os.MkdirAll(repoDir, 0755)
	os.WriteFile(filepath.Join(repoDir, "CLAUDE.md"), []byte("# Project"), 0644)

	// Empty lore file
	lorePath := filepath.Join(dir, "lore.jsonl")
	os.WriteFile(lorePath, []byte(""), 0644)

	c := &Curator{
		InstructionFiles: []string{"CLAUDE.md"},
	}
	proposal, err := c.Curate(context.Background(), "myrepo", repoDir, lorePath)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if proposal != nil {
		t.Error("expected nil proposal when there are no raw entries")
	}
}

func TestCurate_WithEntries(t *testing.T) {
	dir := t.TempDir()
	repoDir := filepath.Join(dir, "repo")
	os.MkdirAll(repoDir, 0755)
	os.WriteFile(filepath.Join(repoDir, "CLAUDE.md"), []byte("# Project"), 0644)

	lorePath := filepath.Join(dir, "lore.jsonl")
	AppendEntry(lorePath, Entry{
		Timestamp: time.Now().UTC(),
		Workspace: "ws-1",
		Agent:     "claude-code",
		Type:      "operational",
		Text:      "always run tests with --race",
	})

	// Mock LLM that returns a valid curator response
	mockExecutor := func(ctx context.Context, prompt string, timeout time.Duration) (string, error) {
		resp := CuratorResponse{
			ProposedFiles:    map[string]string{"CLAUDE.md": "# Project\n\n## Testing\nRun with --race flag."},
			DiffSummary:      "Added testing section",
			EntriesUsed:      []string{"always run tests with --race"},
			EntriesDiscarded: map[string]string{},
		}
		data, _ := json.Marshal(resp)
		return string(data), nil
	}

	c := &Curator{
		InstructionFiles: []string{"CLAUDE.md"},
		Executor:         mockExecutor,
	}

	proposal, err := c.Curate(context.Background(), "myrepo", repoDir, lorePath)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if proposal == nil {
		t.Fatal("expected non-nil proposal")
	}
	if proposal.DiffSummary != "Added testing section" {
		t.Errorf("unexpected summary: %s", proposal.DiffSummary)
	}
	if _, ok := proposal.ProposedFiles["CLAUDE.md"]; !ok {
		t.Error("expected CLAUDE.md in proposed files")
	}
	if proposal.Repo != "myrepo" {
		t.Errorf("expected repo=myrepo, got %s", proposal.Repo)
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./internal/lore/ -run "TestBuildCuratorPrompt|TestParseCuratorResponse|TestCurate"
```

Expected: FAIL

**Step 3: Write minimal implementation**

````go
// internal/lore/curator.go
package lore

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"
)

// Curator reads raw lore entries and instruction files, calls an LLM to produce a merge proposal.
type Curator struct {
	InstructionFiles []string
	Executor         func(ctx context.Context, prompt string, timeout time.Duration) (string, error)
}

// CuratorResponse is the expected JSON output from the curator LLM.
type CuratorResponse struct {
	ProposedFiles    map[string]string `json:"proposed_files"`
	DiffSummary      string            `json:"diff_summary"`
	EntriesUsed      []string          `json:"entries_used"`
	EntriesDiscarded map[string]string `json:"entries_discarded"`
}

// Curate reads raw entries and instruction files, calls the LLM, and returns a Proposal.
// Returns nil if there are no raw entries to curate.
func (c *Curator) Curate(ctx context.Context, repoName, repoDir, lorePath string) (*Proposal, error) {
	// Read raw entries
	entries, err := ReadEntries(lorePath, FilterRaw())
	if err != nil {
		return nil, fmt.Errorf("failed to read lore entries: %w", err)
	}
	if len(entries) == 0 {
		return nil, nil
	}

	// Read instruction files that exist
	instrFiles := make(map[string]string)
	fileHashes := make(map[string]string)
	for _, name := range c.InstructionFiles {
		fullPath := filepath.Join(repoDir, name)
		content, err := os.ReadFile(fullPath)
		if err != nil {
			if os.IsNotExist(err) {
				continue
			}
			return nil, fmt.Errorf("failed to read %s: %w", name, err)
		}
		instrFiles[name] = string(content)
		hash := sha256.Sum256(content)
		fileHashes[name] = "sha256:" + hex.EncodeToString(hash[:])
	}

	if len(instrFiles) == 0 {
		return nil, fmt.Errorf("no instruction files found in %s", repoDir)
	}

	// Build prompt and call LLM
	prompt := BuildCuratorPrompt(instrFiles, entries)
	response, err := c.Executor(ctx, prompt, 120*time.Second)
	if err != nil {
		return nil, fmt.Errorf("curator LLM call failed: %w", err)
	}

	result, err := ParseCuratorResponse(response)
	if err != nil {
		return nil, fmt.Errorf("failed to parse curator response: %w", err)
	}

	// Collect unique source workspaces
	sourceSet := make(map[string]bool)
	for _, e := range entries {
		if e.Workspace != "" {
			sourceSet[e.Workspace] = true
		}
	}
	var sources []string
	for ws := range sourceSet {
		sources = append(sources, ws)
	}

	now := time.Now().UTC()
	proposal := &Proposal{
		ID:               fmt.Sprintf("prop-%s", now.Format("20060102-150405")),
		Repo:             repoName,
		CreatedAt:        now,
		Status:           ProposalPending,
		SourceCount:      len(entries),
		Sources:          sources,
		FileHashes:       fileHashes,
		ProposedFiles:    result.ProposedFiles,
		DiffSummary:      result.DiffSummary,
		EntriesUsed:      result.EntriesUsed,
		EntriesDiscarded: result.EntriesDiscarded,
	}

	return proposal, nil
}

// BuildCuratorPrompt constructs the LLM prompt for curating lore into instruction files.
func BuildCuratorPrompt(instrFiles map[string]string, entries []Entry) string {
	var sb strings.Builder
	sb.WriteString(`You are a curator for a software project's agent instruction files.

You will receive:
1. A list of raw lore entries discovered by AI agents working on this project
2. The current content of all instruction files

Your job is to produce a merge proposal — changes to the instruction files that
incorporate the new lore.

Rules:
- DEDUPLICATE: Collapse similar entries from different agents into one
- FILTER: Discard entries already covered by existing content
- ROUTE: Decide which file(s) each entry belongs in:
  - Universal lore (applies to any agent) → add to ALL instruction files, adapted to each file's style
  - Agent-specific lore → add to that agent's file only
- CATEGORIZE: Place each entry under the appropriate existing section, or propose a new section if none fits
- PRESERVE VOICE: Match the tone, formatting, and style of each file
- NEVER REMOVE existing content — only add or refine
- Output ONLY valid JSON matching the schema below, no markdown fencing

Output schema:
{
  "proposed_files": {"<filename>": "<full proposed content>", ...},
  "diff_summary": "<one-line summary of changes>",
  "entries_used": ["<entry text that was incorporated>", ...],
  "entries_discarded": {"<entry text>": "<reason for discarding>", ...}
}

INSTRUCTION FILES:
`)
	for name, content := range instrFiles {
		fmt.Fprintf(&sb, "\n=== %s ===\n%s\n", name, content)
	}

	sb.WriteString("\nRAW LORE:\n")
	for _, e := range entries {
		fmt.Fprintf(&sb, "- [%s] [%s] [%s] %s\n", e.Agent, e.Type, e.Workspace, e.Text)
	}

	return sb.String()
}

// ParseCuratorResponse parses the LLM JSON response into a CuratorResponse.
func ParseCuratorResponse(response string) (*CuratorResponse, error) {
	// Strip markdown fencing if present
	response = strings.TrimSpace(response)
	if strings.HasPrefix(response, "```") {
		lines := strings.SplitN(response, "\n", 2)
		if len(lines) > 1 {
			response = lines[1]
		}
		if idx := strings.LastIndex(response, "```"); idx >= 0 {
			response = response[:idx]
		}
		response = strings.TrimSpace(response)
	}

	var result CuratorResponse
	if err := json.Unmarshal([]byte(response), &result); err != nil {
		return nil, fmt.Errorf("invalid curator JSON: %w", err)
	}
	return &result, nil
}
````

**Step 4: Run test to verify it passes**

```bash
go test ./internal/lore/ -run "TestBuildCuratorPrompt|TestParseCuratorResponse|TestCurate"
```

Expected: PASS

**Step 5: Commit**

```bash
git add internal/lore/curator.go internal/lore/curator_test.go
git commit -m "Add lore curator with LLM prompt construction and response parsing"
```

---

### Task 7: Apply logic — temp worktree, commit, push, dispose

**Files:**

- Create: `internal/lore/apply.go`
- Create: `internal/lore/apply_test.go`

**Step 1: Write the failing test**

The apply logic requires git operations, so we test with real temp git repos.

```go
// internal/lore/apply_test.go
package lore

import (
	"context"
	"os"
	"os/exec"
	"path/filepath"
	"testing"
)

// initBareRepo creates a bare repo with a CLAUDE.md file for testing.
func initBareRepo(t *testing.T) (bareDir string) {
	t.Helper()
	dir := t.TempDir()

	// Create a normal repo first
	normalDir := filepath.Join(dir, "normal")
	os.MkdirAll(normalDir, 0755)
	run(t, normalDir, "git", "init")
	run(t, normalDir, "git", "config", "user.email", "test@test.com")
	run(t, normalDir, "git", "config", "user.name", "test")
	os.WriteFile(filepath.Join(normalDir, "CLAUDE.md"), []byte("# Project\n"), 0644)
	run(t, normalDir, "git", "add", "CLAUDE.md")
	run(t, normalDir, "git", "commit", "-m", "initial")

	// Clone as bare
	bareDir = filepath.Join(dir, "bare.git")
	run(t, dir, "git", "clone", "--bare", normalDir, bareDir)
	// Set up fetch refspec
	run(t, bareDir, "git", "config", "remote.origin.fetch", "+refs/heads/*:refs/remotes/origin/*")
	return bareDir
}

func run(t *testing.T, dir string, name string, args ...string) {
	t.Helper()
	cmd := exec.Command(name, args...)
	cmd.Dir = dir
	if output, err := cmd.CombinedOutput(); err != nil {
		t.Fatalf("%s %v failed: %v: %s", name, args, err, string(output))
	}
}

func TestApplyProposal(t *testing.T) {
	bareDir := initBareRepo(t)
	workDir := t.TempDir() // where temp worktrees go

	proposal := &Proposal{
		ID:   "prop-test-001",
		Repo: "myrepo",
		ProposedFiles: map[string]string{
			"CLAUDE.md": "# Project\n\n## Build\nAlways use go run ./cmd/build-dashboard\n",
		},
	}

	result, err := ApplyProposal(context.Background(), proposal, bareDir, workDir)
	if err != nil {
		t.Fatalf("apply failed: %v", err)
	}
	if result.Branch == "" {
		t.Error("expected a branch name")
	}

	// Verify the branch exists in the bare repo
	cmd := exec.Command("git", "show-ref", "--verify", "--quiet", "refs/heads/"+result.Branch)
	cmd.Dir = bareDir
	if err := cmd.Run(); err != nil {
		t.Errorf("branch %s should exist in bare repo", result.Branch)
	}

	// Verify the file content on the branch
	showCmd := exec.Command("git", "show", result.Branch+":CLAUDE.md")
	showCmd.Dir = bareDir
	output, err := showCmd.Output()
	if err != nil {
		t.Fatalf("git show failed: %v", err)
	}
	if string(output) != "# Project\n\n## Build\nAlways use go run ./cmd/build-dashboard\n" {
		t.Errorf("unexpected file content on branch: %s", string(output))
	}

	// Verify temp worktree was cleaned up
	entries, _ := os.ReadDir(workDir)
	if len(entries) != 0 {
		t.Errorf("expected temp worktree to be cleaned up, found %d entries", len(entries))
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./internal/lore/ -run "TestApplyProposal"
```

Expected: FAIL

**Step 3: Write minimal implementation**

```go
// internal/lore/apply.go
package lore

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"time"
)

// ApplyResult holds the output of applying a proposal.
type ApplyResult struct {
	Branch string // the branch that was created and committed to
}

// ApplyProposal creates a temp worktree, writes instruction files, commits, and cleans up.
// It does NOT push — the caller decides whether to push.
// bareDir is the path to the bare clone. workBaseDir is where temp worktrees are created.
func ApplyProposal(ctx context.Context, proposal *Proposal, bareDir, workBaseDir string) (*ApplyResult, error) {
	now := time.Now().UTC()
	branch := fmt.Sprintf("schmux/lore-%s", now.Format("20060102-150405"))

	// Determine default branch to branch from
	defaultBranch, err := getDefaultBranch(ctx, bareDir)
	if err != nil {
		return nil, fmt.Errorf("failed to get default branch: %w", err)
	}

	// Create branch from default branch
	if err := runGit(ctx, bareDir, "branch", branch, defaultBranch); err != nil {
		return nil, fmt.Errorf("failed to create branch: %w", err)
	}

	// Create temp worktree
	worktreePath := filepath.Join(workBaseDir, "lore-"+now.Format("20060102-150405"))
	if err := runGit(ctx, bareDir, "worktree", "add", worktreePath, branch); err != nil {
		return nil, fmt.Errorf("failed to create worktree: %w", err)
	}

	// Ensure cleanup
	defer func() {
		runGit(ctx, bareDir, "worktree", "remove", "--force", worktreePath)
	}()

	// Configure git user in worktree
	runGit(ctx, worktreePath, "config", "user.email", "schmux@localhost")
	runGit(ctx, worktreePath, "config", "user.name", "schmux-lore")

	// Write proposed files
	var filesToAdd []string
	for relPath, content := range proposal.ProposedFiles {
		fullPath := filepath.Join(worktreePath, relPath)
		if err := os.MkdirAll(filepath.Dir(fullPath), 0755); err != nil {
			return nil, fmt.Errorf("failed to create directory for %s: %w", relPath, err)
		}
		if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
			return nil, fmt.Errorf("failed to write %s: %w", relPath, err)
		}
		filesToAdd = append(filesToAdd, relPath)
	}

	// Stage and commit
	addArgs := append([]string{"add"}, filesToAdd...)
	if err := runGit(ctx, worktreePath, addArgs...); err != nil {
		return nil, fmt.Errorf("git add failed: %w", err)
	}

	n := len(proposal.ProposedFiles)
	msg := fmt.Sprintf("chore: update instruction files with agent lore (%d files)", n)
	if proposal.DiffSummary != "" {
		msg = fmt.Sprintf("chore: update instruction files with agent lore\n\n%s", proposal.DiffSummary)
	}
	if err := runGit(ctx, worktreePath, "commit", "-m", msg); err != nil {
		return nil, fmt.Errorf("git commit failed: %w", err)
	}

	return &ApplyResult{Branch: branch}, nil
}

// PushBranch pushes a branch to origin.
func PushBranch(ctx context.Context, bareDir, branch string) error {
	return runGit(ctx, bareDir, "push", "origin", branch)
}

func getDefaultBranch(ctx context.Context, bareDir string) (string, error) {
	cmd := exec.CommandContext(ctx, "git", "symbolic-ref", "HEAD")
	cmd.Dir = bareDir
	output, err := cmd.Output()
	if err != nil {
		// Fall back to "main"
		return "main", nil
	}
	ref := strings.TrimSpace(string(output))
	// refs/heads/main -> main
	return strings.TrimPrefix(ref, "refs/heads/"), nil
}

func runGit(ctx context.Context, dir string, args ...string) error {
	cmd := exec.CommandContext(ctx, "git", args...)
	cmd.Dir = dir
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("git %v: %w: %s", args, err, string(output))
	}
	return nil
}
```

Note: You'll need to add `"strings"` to the imports.

**Step 4: Run test to verify it passes**

```bash
go test ./internal/lore/ -run "TestApplyProposal"
```

Expected: PASS

**Step 5: Commit**

```bash
git add internal/lore/apply.go internal/lore/apply_test.go
git commit -m "Add lore apply logic with temp worktree commit workflow"
```

---

### Task 8: Daemon integration — curator trigger on session dispose

**Files:**

- Modify: `internal/daemon/daemon.go:440-563` (compounder wiring section)
- Modify: `internal/daemon/daemon.go:58-64` (Daemon struct)

This task wires the lore system into the daemon lifecycle. No isolated unit test is practical here — it's integration wiring. Instead, verify with a compile check and the existing test suite.

**Step 1: Read the daemon wiring section for context**

Review `internal/daemon/daemon.go` lines 440-563 to understand the compounder callback pattern.

**Step 2: Add lore fields to daemon and wire curator**

In the `Daemon` struct, add no new fields — the lore system is stateless (proposal store on disk, curator is a function call). Instead, add lore wiring in the `Run()` function, after the compounder setup.

In `daemon.go`, after the compounder startup block (around line 563), add:

```go
// Lore system: trigger curator on session dispose
var loreCurateTimer *time.Timer
var loreCurateMu sync.Mutex
if cfg.GetLoreEnabled() {
	loreProposalDir := filepath.Join(homeDir, ".schmux", "lore-proposals")
	loreStore := lore.NewProposalStore(loreProposalDir)

	loreCurator := &lore.Curator{
		InstructionFiles: cfg.GetLoreInstructionFiles(),
	}
	if target := cfg.GetLoreTarget(); target != "" {
		loreCurator.Executor = func(ctx context.Context, prompt string, timeout time.Duration) (string, error) {
			return oneshot.ExecuteTarget(ctx, cfg, target, prompt, "", timeout, "")
		}
	}

	sm.SetLoreCallback(func(repoName, repoURL string) {
		if !cfg.GetLoreCurateOnDispose() || loreCurator.Executor == nil {
			return
		}
		loreCurateMu.Lock()
		if loreCurateTimer != nil {
			loreCurateTimer.Stop()
		}
		debounce := time.Duration(cfg.GetLoreCurateDebounceMs()) * time.Millisecond
		loreCurateTimer = time.AfterFunc(debounce, func() {
			// Find overlay lore path
			overlayDir, err := workspace.OverlayDir(repoName)
			if err != nil {
				fmt.Printf("[lore] failed to get overlay dir: %v\n", err)
				return
			}
			lorePath := filepath.Join(overlayDir, ".claude", "lore.jsonl")

			// Find repo dir (bare clone) to read instruction files
			repo, found := cfg.FindRepoByURL(repoURL)
			if !found {
				fmt.Printf("[lore] repo not found for URL: %s\n", repoURL)
				return
			}
			bareDir := filepath.Join(cfg.GetWorktreeBasePath(), repo.BarePath)

			// Create a temp worktree to read instruction files from
			// (bare repos can't read files directly without git show)
			// For now, use git show to read files from HEAD
			// TODO: This needs refinement — reading from bare repo with git show

			proposal, err := loreCurator.Curate(context.Background(), repoName, bareDir, lorePath)
			if err != nil {
				fmt.Printf("[lore] curation failed: %v\n", err)
				return
			}
			if proposal == nil {
				fmt.Printf("[lore] no raw entries to curate for %s\n", repoName)
				return
			}

			if err := loreStore.Save(proposal); err != nil {
				fmt.Printf("[lore] failed to save proposal: %v\n", err)
				return
			}
			fmt.Printf("[lore] proposal %s created for %s: %s\n", proposal.ID, repoName, proposal.DiffSummary)

			// TODO: notify dashboard via WebSocket
		})
		loreCurateMu.Unlock()
	})
}
```

**Important:** The curator currently reads instruction files from `repoDir`. Since the base repo is a bare clone, reading files requires `git show HEAD:<file>`. The `Curator.Curate()` method needs a small refactor to support reading from bare repos. For now, note this as a TODO — the curator can read from any worktree that happens to be alive, or we add a `ReadFromBareRepo` helper.

**Step 3: Add SetLoreCallback to session manager**

In `internal/session/manager.go`, add:

```go
loreCallback func(repoName, repoURL string) // field on Manager

func (m *Manager) SetLoreCallback(cb func(repoName, repoURL string)) {
	m.loreCallback = cb
}
```

In the session dispose path (where `compoundCallback` is called with `isSpawn=false`), add a call to `loreCallback` after the compound callback.

**Step 4: Run full test suite to verify nothing breaks**

```bash
go test ./...
```

Expected: PASS (no behavioral changes yet, just wiring)

**Step 5: Commit**

```bash
git add internal/daemon/daemon.go internal/session/manager.go
git commit -m "Wire lore curator into daemon with debounced session-dispose trigger"
```

---

### Task 9: Dashboard API endpoints

**Files:**

- Create: `internal/dashboard/handlers_lore.go`
- Modify: `internal/dashboard/server.go:246-319` (add routes)

**Step 1: Write the handler implementations**

```go
// internal/dashboard/handlers_lore.go
package dashboard

import (
	"encoding/json"
	"net/http"
	"strings"

	"github.com/sergeknystautas/schmux/internal/lore"
)

func (s *Server) handleLoreProposals(w http.ResponseWriter, r *http.Request) {
	// Extract repoName from path: /api/lore/{repoName}/proposals
	parts := strings.Split(strings.TrimPrefix(r.URL.Path, "/api/lore/"), "/")
	if len(parts) < 2 || parts[0] == "" {
		http.Error(w, "missing repo name", http.StatusBadRequest)
		return
	}
	repoName := parts[0]

	if s.loreStore == nil {
		http.Error(w, "lore system not enabled", http.StatusServiceUnavailable)
		return
	}

	proposals, err := s.loreStore.List(repoName)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"proposals": proposals,
	})
}

func (s *Server) handleLoreProposalGet(w http.ResponseWriter, r *http.Request) {
	// /api/lore/{repoName}/proposals/{id}
	parts := strings.Split(strings.TrimPrefix(r.URL.Path, "/api/lore/"), "/")
	if len(parts) < 3 {
		http.Error(w, "missing repo name or proposal id", http.StatusBadRequest)
		return
	}
	repoName, proposalID := parts[0], parts[2]

	proposal, err := s.loreStore.Get(repoName, proposalID)
	if err != nil {
		http.Error(w, err.Error(), http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(proposal)
}

func (s *Server) handleLoreApply(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	// /api/lore/{repoName}/proposals/{id}/apply
	parts := strings.Split(strings.TrimPrefix(r.URL.Path, "/api/lore/"), "/")
	if len(parts) < 4 {
		http.Error(w, "invalid path", http.StatusBadRequest)
		return
	}
	repoName, proposalID := parts[0], parts[2]

	proposal, err := s.loreStore.Get(repoName, proposalID)
	if err != nil {
		http.Error(w, err.Error(), http.StatusNotFound)
		return
	}

	// Check for overrides in request body
	var body struct {
		Overrides map[string]string `json:"overrides"`
	}
	if r.Body != nil {
		json.NewDecoder(r.Body).Decode(&body)
		for k, v := range body.Overrides {
			proposal.ProposedFiles[k] = v
		}
	}

	// Find the bare repo dir
	repo, found := s.config.FindRepoByName(repoName)
	if !found {
		http.Error(w, "repo not found", http.StatusNotFound)
		return
	}
	bareDir := filepath.Join(s.config.GetWorktreeBasePath(), repo.BarePath)
	workDir := filepath.Join(os.TempDir(), "schmux-lore-apply")
	os.MkdirAll(workDir, 0755)

	result, err := lore.ApplyProposal(r.Context(), proposal, bareDir, workDir)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	// Push if configured
	if s.config.GetLoreAutoPR() {
		if err := lore.PushBranch(r.Context(), bareDir, result.Branch); err != nil {
			http.Error(w, fmt.Sprintf("commit succeeded but push failed: %v", err), http.StatusInternalServerError)
			return
		}
	}

	// Update proposal status
	s.loreStore.UpdateStatus(repoName, proposalID, lore.ProposalApplied)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"status": "applied",
		"branch": result.Branch,
	})
}

func (s *Server) handleLoreDismiss(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	parts := strings.Split(strings.TrimPrefix(r.URL.Path, "/api/lore/"), "/")
	if len(parts) < 4 {
		http.Error(w, "invalid path", http.StatusBadRequest)
		return
	}
	repoName, proposalID := parts[0], parts[2]

	if err := s.loreStore.UpdateStatus(repoName, proposalID, lore.ProposalDismissed); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"status": "dismissed"})
}

func (s *Server) handleLoreEntries(w http.ResponseWriter, r *http.Request) {
	parts := strings.Split(strings.TrimPrefix(r.URL.Path, "/api/lore/"), "/")
	if len(parts) < 2 {
		http.Error(w, "missing repo name", http.StatusBadRequest)
		return
	}
	repoName := parts[0]

	overlayDir, err := workspace.OverlayDir(repoName)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	lorePath := filepath.Join(overlayDir, ".claude", "lore.jsonl")

	entries, err := lore.ReadEntries(lorePath, nil) // return all entries, let frontend filter
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"entries": entries,
	})
}

func (s *Server) handleLoreCurate(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	// Manual curation trigger — implementation depends on daemon wiring
	// For now, return not implemented
	http.Error(w, "manual curation not yet implemented", http.StatusNotImplemented)
}
```

**Step 2: Add `loreStore` field to Server and register routes**

In `server.go`, add a `loreStore *lore.ProposalStore` field to the `Server` struct. Initialize it in `NewServer()`. Register routes in the mux setup:

```go
mux.HandleFunc("/api/lore/", s.withCORS(s.withAuth(s.handleLoreRouter)))
```

Add a router method:

```go
func (s *Server) handleLoreRouter(w http.ResponseWriter, r *http.Request) {
	path := strings.TrimPrefix(r.URL.Path, "/api/lore/")
	parts := strings.Split(path, "/")

	switch {
	case len(parts) >= 4 && parts[1] == "proposals" && parts[3] == "apply":
		s.handleLoreApply(w, r)
	case len(parts) >= 4 && parts[1] == "proposals" && parts[3] == "dismiss":
		s.handleLoreDismiss(w, r)
	case len(parts) >= 3 && parts[1] == "proposals":
		s.handleLoreProposalGet(w, r)
	case len(parts) >= 2 && parts[1] == "proposals":
		s.handleLoreProposals(w, r)
	case len(parts) >= 2 && parts[1] == "entries":
		s.handleLoreEntries(w, r)
	case len(parts) >= 2 && parts[1] == "curate":
		s.handleLoreCurate(w, r)
	default:
		http.Error(w, "not found", http.StatusNotFound)
	}
}
```

**Step 3: Run compile check and existing tests**

```bash
go build ./... && go test ./internal/dashboard/...
```

Expected: PASS

**Step 4: Commit**

```bash
git add internal/dashboard/handlers_lore.go internal/dashboard/server.go
git commit -m "Add lore dashboard API endpoints for proposals, entries, apply, dismiss"
```

---

### Task 10: Frontend types and API client

**Files:**

- Modify: `assets/dashboard/src/lib/types.ts`
- Modify: `assets/dashboard/src/lib/api.ts`

**Step 1: Add TypeScript types**

In `types.ts`:

```typescript
export interface LoreEntry {
  ts: string;
  ws?: string;
  agent?: string;
  type?: string;
  text?: string;
  state_change?: string;
  entry_ts?: string;
  proposal_id?: string;
}

export interface LoreProposal {
  id: string;
  repo: string;
  created_at: string;
  status: 'pending' | 'stale' | 'applied' | 'dismissed';
  source_count: number;
  sources: string[];
  file_hashes: Record<string, string>;
  proposed_files: Record<string, string>;
  diff_summary: string;
  entries_used: string[];
  entries_discarded?: Record<string, string>;
}

export interface LoreProposalsResponse {
  proposals: LoreProposal[];
}

export interface LoreEntriesResponse {
  entries: LoreEntry[];
}

export interface LoreApplyResponse {
  status: string;
  branch: string;
}
```

**Step 2: Add API functions**

In `api.ts`:

```typescript
export async function getLoreProposals(repoName: string): Promise<LoreProposalsResponse> {
  const res = await fetch(`/api/lore/${repoName}/proposals`);
  if (!res.ok) throw new Error(await res.text());
  return res.json();
}

export async function getLoreProposal(repoName: string, id: string): Promise<LoreProposal> {
  const res = await fetch(`/api/lore/${repoName}/proposals/${id}`);
  if (!res.ok) throw new Error(await res.text());
  return res.json();
}

export async function applyLoreProposal(
  repoName: string,
  id: string,
  overrides?: Record<string, string>
): Promise<LoreApplyResponse> {
  const res = await fetch(`/api/lore/${repoName}/proposals/${id}/apply`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: overrides ? JSON.stringify({ overrides }) : undefined,
  });
  if (!res.ok) throw new Error(await res.text());
  return res.json();
}

export async function dismissLoreProposal(repoName: string, id: string): Promise<void> {
  const res = await fetch(`/api/lore/${repoName}/proposals/${id}/dismiss`, { method: 'POST' });
  if (!res.ok) throw new Error(await res.text());
}

export async function getLoreEntries(repoName: string): Promise<LoreEntriesResponse> {
  const res = await fetch(`/api/lore/${repoName}/entries`);
  if (!res.ok) throw new Error(await res.text());
  return res.json();
}

export async function triggerLoreCuration(repoName: string): Promise<void> {
  const res = await fetch(`/api/lore/${repoName}/curate`, { method: 'POST' });
  if (!res.ok) throw new Error(await res.text());
}
```

**Step 3: Build the dashboard to verify**

```bash
go run ./cmd/build-dashboard
```

Expected: Build succeeds

**Step 4: Commit**

```bash
git add assets/dashboard/src/lib/types.ts assets/dashboard/src/lib/api.ts
git commit -m "Add lore TypeScript types and API client functions"
```

---

### Task 11: Dashboard LorePage component

**Files:**

- Create: `assets/dashboard/src/routes/LorePage.tsx`
- Create: `assets/dashboard/src/styles/lore.module.css`
- Modify: `assets/dashboard/src/App.tsx` (add route)

This is a large frontend task. The implementer should reference `docs/specs/lore.md` sections "Dashboard Integration" and "Lore Page" for the UX spec, and follow the pattern from existing pages like `OverlayPage.tsx` or `ConfigPage.tsx`.

**Key components to build:**

1. **Proposals list** — fetches `getLoreProposals(repoName)`, renders each with timestamp, summary, source count, status badge
2. **Proposal detail/diff view** — shows tabs per file, diff with additions highlighted, Apply/Edit/Dismiss buttons
3. **Raw entries log** — fetches `getLoreEntries(repoName)`, scrollable list with filters
4. **Route registration** — add `<Route path="/lore/:repoName" element={<LorePage />} />` in App.tsx

**Step 1: Create the page component**

Create `assets/dashboard/src/routes/LorePage.tsx` following the pattern from existing pages. Use `useParams()` to get `repoName`. Fetch proposals on mount. Show proposals list and raw entries in two sections.

The diff view can use a simple side-by-side comparison initially — a full diff library can be added later.

**Step 2: Add the route**

In `App.tsx`, import `LorePage` and add:

```tsx
<Route path="/lore/:repoName" element={<LorePage />} />
```

**Step 3: Build and verify**

```bash
go run ./cmd/build-dashboard
```

Expected: Build succeeds

**Step 4: Commit**

```bash
git add assets/dashboard/src/routes/LorePage.tsx assets/dashboard/src/styles/lore.module.css assets/dashboard/src/App.tsx
git commit -m "Add LorePage dashboard component with proposals list and diff view"
```

---

### Task 12: Sidebar badge for pending proposals

**Files:**

- Modify: `assets/dashboard/src/components/AppShell.tsx`

**Step 1: Add lore nav link with badge**

In the sidebar section of `AppShell.tsx`, add a "Lore" nav link for each repo. Fetch pending proposal counts via the existing config/sessions context or a new lightweight endpoint.

For each repo in the config, add:

```tsx
<NavLink to={`/lore/${repo.name}`} className={/* existing pattern */}>
  Lore
  {loreCounts[repo.name] > 0 && <span className={styles.badge}>{loreCounts[repo.name]}</span>}
</NavLink>
```

**Step 2: Build and verify**

```bash
go run ./cmd/build-dashboard
```

**Step 3: Commit**

```bash
git add assets/dashboard/src/components/AppShell.tsx
git commit -m "Add lore nav link with pending proposal badge to sidebar"
```

---

### Task 13: Self-bootstrap — add lore capture instructions

**Files:**

- Modify: `CLAUDE.md`
- Modify: `AGENTS.md`

**Step 1: Add the lore capture section**

At the end of `CLAUDE.md` (before any closing sections), add:

```markdown
## Lore Capture

As you work, append discoveries to `.claude/lore.jsonl` — things you learned
that aren't already documented in this file. One JSON line per entry:
```

{"ts":"<ISO8601>","ws":"<workspace-id>","agent":"claude-code","type":"operational|codebase","text":"<what you learned>"}

```

Don't evaluate importance. Don't read the file first. Just append.
```

Add the equivalent section to `AGENTS.md`.

**Step 2: Commit**

```bash
git add CLAUDE.md AGENTS.md
git commit -m "Add lore capture instructions to CLAUDE.md and AGENTS.md"
```

---

### Task 14: Read instruction files from bare repo

The curator needs to read instruction files (CLAUDE.md, etc.) but the base repo is a bare clone. Add a helper that uses `git show HEAD:<file>` to read file content from the bare repo.

**Files:**

- Modify: `internal/lore/curator.go`
- Modify: `internal/lore/curator_test.go`

**Step 1: Write the failing test**

```go
func TestReadFileFromBareRepo(t *testing.T) {
	bareDir := initBareRepo(t) // reuse helper from apply_test.go
	content, err := ReadFileFromRepo(context.Background(), bareDir, "CLAUDE.md")
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if content != "# Project\n" {
		t.Errorf("unexpected content: %q", content)
	}
}

func TestReadFileFromBareRepo_NotFound(t *testing.T) {
	bareDir := initBareRepo(t)
	_, err := ReadFileFromRepo(context.Background(), bareDir, "NONEXISTENT.md")
	if err == nil {
		t.Error("expected error for nonexistent file")
	}
}
```

**Step 2: Run test to verify it fails**

```bash
go test ./internal/lore/ -run "TestReadFileFromBareRepo"
```

**Step 3: Implement**

```go
// ReadFileFromRepo reads a file from HEAD in a git repo (works with bare repos).
func ReadFileFromRepo(ctx context.Context, repoDir, relPath string) (string, error) {
	cmd := exec.CommandContext(ctx, "git", "show", "HEAD:"+relPath)
	cmd.Dir = repoDir
	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("git show HEAD:%s failed: %w", relPath, err)
	}
	return string(output), nil
}
```

Then update `Curator.Curate()` to use `ReadFileFromRepo` instead of `os.ReadFile` when reading instruction files. Add a `BareRepo bool` field to `Curator` (or a `RepoReader` function type) to support both modes.

**Step 4: Run test to verify it passes**

```bash
go test ./internal/lore/ -run "TestReadFileFromBareRepo"
```

**Step 5: Commit**

```bash
git add internal/lore/curator.go internal/lore/curator_test.go
git commit -m "Add bare repo file reading for lore curator"
```

---

### Task 15: Full test suite run

**Step 1: Run all tests**

```bash
./test.sh --all
```

Expected: All pass.

**Step 2: Run formatting**

```bash
./format.sh
```

**Step 3: Final commit if formatting changed anything**

```bash
git add -A && git commit -m "Format code" || echo "nothing to format"
```

---

## Task Dependency Graph

```
Task 1 (Config) ──────────────────┐
Task 2 (Scratchpad) ──────────────┤
Task 3 (Overlay paths) ───────────┤
Task 4 (JSONL merge) ─────────────┤
                                   ├── Task 8 (Daemon wiring)
Task 5 (Proposal store) ──────────┤
Task 6 (Curator) ─────────────────┤
Task 7 (Apply) ────────────────────┘
Task 14 (Bare repo read) ─── depends on Task 6, 7

Task 9 (API endpoints) ─── depends on Task 5, 7, 8
Task 10 (TS types/API) ─── depends on Task 9
Task 11 (LorePage) ─── depends on Task 10
Task 12 (Sidebar badge) ─── depends on Task 11
Task 13 (Self-bootstrap) ─── independent, can run anytime

Task 15 (Full test run) ─── depends on all above
```

Tasks 1-7 and 14 can be parallelized across subagents (they touch independent files). Tasks 9-12 are sequential (each depends on the previous).
